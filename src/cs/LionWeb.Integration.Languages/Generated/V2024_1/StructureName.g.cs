// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2;
using LionWeb.Core;
using LionWeb.Core.M1.Event.Partition;
using LionWeb.Core.M1.Event.Partition.Emitter;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2024_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "structure-name", Version = "1")]
public partial class StructureNameLanguage : LanguageBase<IStructureNameFactory>
{
	public static readonly StructureNameLanguage Instance = new Lazy<StructureNameLanguage>(() => new("id-structure-name-lang")).Value;
	public StructureNameLanguage(string id) : base(id, LionWebVersions.v2024_1)
	{
		_annotationAnnotation = new(() => new AnnotationBase<StructureNameLanguage>("id-annotation", this) { Key = "key-annotation", Name = "AnnotationAnnotation", AnnotatesLazy = new(() => _builtIns.Node), ImplementsLazy = new(() => [InterfaceIface]), FeaturesLazy = new(() => [AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested]) });
		_annotationAnnotation_ContainmentOptionalMultipleAnnotationNested = new(() => new ContainmentBase<StructureNameLanguage>("id-containment-optional-multiple-annotationNested", AnnotationAnnotation, this) { Key = "key-containment-optional-multiple-annotationNested", Name = "ContainmentOptionalMultipleAnnotationNested", Optional = true, Multiple = true, Type = InterfaceIface });
		_conceptConcept = new(() => new ConceptBase<StructureNameLanguage>("id-concept", this) { Key = "key-concept", Name = "ConceptConcept", Abstract = false, Partition = false, ImplementsLazy = new(() => [InterfaceIface]), FeaturesLazy = new(() => [ConceptConcept_ContainmentOptionalMultipleConceptNested]) });
		_conceptConcept_ContainmentOptionalMultipleConceptNested = new(() => new ContainmentBase<StructureNameLanguage>("id-containment-optional-multiple-conceptNested", ConceptConcept, this) { Key = "key-containment-optional-multiple-conceptNested", Name = "ContainmentOptionalMultipleConceptNested", Optional = true, Multiple = true, Type = InterfaceIface });
		_conceptPartition = new(() => new ConceptBase<StructureNameLanguage>("id-partition", this) { Key = "key-partition", Name = "ConceptPartition", Abstract = false, Partition = true, FeaturesLazy = new(() => [ConceptPartition_ContainmentOptionalMultiple, ConceptPartition_ContainmentOptionalSingle, ConceptPartition_ContainmentRequiredMultiple, ConceptPartition_ContainmentRequiredSingle, ConceptPartition_propertyBooleanOptional, ConceptPartition_propertyBooleanRequired, ConceptPartition_propertyIntegerOptional, ConceptPartition_propertyIntegerRequired, ConceptPartition_propertySdtOptional, ConceptPartition_propertySdtRequired, ConceptPartition_propertyStringOptional, ConceptPartition_propertyStringRequired, ConceptPartition_ReferenceOptionalMultiple, ConceptPartition_ReferenceOptionalSingle, ConceptPartition_ReferenceRequiredMultiple, ConceptPartition_ReferenceRequiredSingle]) });
		_conceptPartition_ContainmentOptionalMultiple = new(() => new ContainmentBase<StructureNameLanguage>("id-containment-optional-multiple", ConceptPartition, this) { Key = "key-containment-optional-multiple", Name = "ContainmentOptionalMultiple", Optional = true, Multiple = true, Type = InterfaceIface });
		_conceptPartition_ContainmentOptionalSingle = new(() => new ContainmentBase<StructureNameLanguage>("id-containment-optional-single", ConceptPartition, this) { Key = "key-containment-optional-single", Name = "ContainmentOptionalSingle", Optional = true, Multiple = false, Type = InterfaceIface });
		_conceptPartition_ContainmentRequiredMultiple = new(() => new ContainmentBase<StructureNameLanguage>("id-containment-required-multiple", ConceptPartition, this) { Key = "key-containment-required-multiple", Name = "ContainmentRequiredMultiple", Optional = false, Multiple = true, Type = InterfaceIface });
		_conceptPartition_ContainmentRequiredSingle = new(() => new ContainmentBase<StructureNameLanguage>("id-containment-required-single", ConceptPartition, this) { Key = "key-containment-required-single", Name = "ContainmentRequiredSingle", Optional = false, Multiple = false, Type = InterfaceIface });
		_conceptPartition_propertyBooleanOptional = new(() => new PropertyBase<StructureNameLanguage>("id-property-boolean-optional", ConceptPartition, this) { Key = "key-property-boolean-optional", Name = "propertyBooleanOptional", Optional = true, Type = _builtIns.Boolean });
		_conceptPartition_propertyBooleanRequired = new(() => new PropertyBase<StructureNameLanguage>("id-property-boolean-required", ConceptPartition, this) { Key = "key-property-boolean-required", Name = "propertyBooleanRequired", Optional = false, Type = _builtIns.Boolean });
		_conceptPartition_propertyIntegerOptional = new(() => new PropertyBase<StructureNameLanguage>("id-property-integer-optional", ConceptPartition, this) { Key = "key-property-integer-optional", Name = "propertyIntegerOptional", Optional = true, Type = _builtIns.Integer });
		_conceptPartition_propertyIntegerRequired = new(() => new PropertyBase<StructureNameLanguage>("id-property-integer-required", ConceptPartition, this) { Key = "key-property-integer-required", Name = "propertyIntegerRequired", Optional = false, Type = _builtIns.Integer });
		_conceptPartition_propertySdtOptional = new(() => new PropertyBase<StructureNameLanguage>("id-property-sdt-optional", ConceptPartition, this) { Key = "key-property-sdt-optional", Name = "propertySdtOptional", Optional = true, Type = SdtNested });
		_conceptPartition_propertySdtRequired = new(() => new PropertyBase<StructureNameLanguage>("id-property-sdt-required", ConceptPartition, this) { Key = "key-property-sdt-required", Name = "propertySdtRequired", Optional = false, Type = SdtNested });
		_conceptPartition_propertyStringOptional = new(() => new PropertyBase<StructureNameLanguage>("id-property-string-optional", ConceptPartition, this) { Key = "key-property-string-optional", Name = "propertyStringOptional", Optional = true, Type = _builtIns.String });
		_conceptPartition_propertyStringRequired = new(() => new PropertyBase<StructureNameLanguage>("id-property-string-required", ConceptPartition, this) { Key = "key-property-string-required", Name = "propertyStringRequired", Optional = false, Type = _builtIns.String });
		_conceptPartition_ReferenceOptionalMultiple = new(() => new ReferenceBase<StructureNameLanguage>("id-reference-optional-multiple", ConceptPartition, this) { Key = "key-reference-optional-multiple", Name = "ReferenceOptionalMultiple", Optional = true, Multiple = true, Type = InterfaceIface });
		_conceptPartition_ReferenceOptionalSingle = new(() => new ReferenceBase<StructureNameLanguage>("id-reference-optional-single", ConceptPartition, this) { Key = "key-reference-optional-single", Name = "ReferenceOptionalSingle", Optional = true, Multiple = false, Type = InterfaceIface });
		_conceptPartition_ReferenceRequiredMultiple = new(() => new ReferenceBase<StructureNameLanguage>("id-reference-required-multiple", ConceptPartition, this) { Key = "key-reference-required-multiple", Name = "ReferenceRequiredMultiple", Optional = false, Multiple = true, Type = InterfaceIface });
		_conceptPartition_ReferenceRequiredSingle = new(() => new ReferenceBase<StructureNameLanguage>("id-reference-required-single", ConceptPartition, this) { Key = "key-reference-required-single", Name = "ReferenceRequiredSingle", Optional = false, Multiple = false, Type = InterfaceIface });
		_interfaceIface = new(() => new InterfaceBase<StructureNameLanguage>("id-interface", this) { Key = "key-interface", Name = "InterfaceIface", ExtendsLazy = new(() => [_builtIns.INamed]) });
		_sdtDecimal = new(() => new StructuredDataTypeBase<StructureNameLanguage>("id-sdt-decimal", this) { Key = "key-sdt-decimal", Name = "SdtDecimal", FieldsLazy = new(() => [SdtDecimal_fieldFraction, SdtDecimal_fieldWhole]) });
		_sdtDecimal_fieldFraction = new(() => new FieldBase<StructureNameLanguage>("id-field-decimal-fraction", SdtDecimal, this) { Key = "key-field-decimal-fraction", Name = "fieldFraction", Type = _builtIns.Integer });
		_sdtDecimal_fieldWhole = new(() => new FieldBase<StructureNameLanguage>("id-field-decimal-whole", SdtDecimal, this) { Key = "key-field-decimal-whole", Name = "fieldWhole", Type = _builtIns.Integer });
		_sdtNested = new(() => new StructuredDataTypeBase<StructureNameLanguage>("id-sdt-nested", this) { Key = "key-sdt-neested", Name = "SdtNested", FieldsLazy = new(() => [SdtNested_fieldBoolean, SdtNested_fieldDecimal, SdtNested_fieldString]) });
		_sdtNested_fieldBoolean = new(() => new FieldBase<StructureNameLanguage>("id-field-nested-boolean", SdtNested, this) { Key = "key-field-nested-boolean", Name = "fieldBoolean", Type = _builtIns.Boolean });
		_sdtNested_fieldDecimal = new(() => new FieldBase<StructureNameLanguage>("id-field-nested-decimal", SdtNested, this) { Key = "key-field-nested-decimal", Name = "fieldDecimal", Type = SdtDecimal });
		_sdtNested_fieldString = new(() => new FieldBase<StructureNameLanguage>("id-field-nested-string", SdtNested, this) { Key = "key-field-nested-string", Name = "fieldString", Type = _builtIns.String });
		_factory = new StructureNameFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [AnnotationAnnotation, ConceptConcept, ConceptPartition, InterfaceIface, SdtDecimal, SdtNested];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "structure-name";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "StructureName";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Annotation> _annotationAnnotation;
	public Annotation AnnotationAnnotation => _annotationAnnotation.Value;

	private readonly Lazy<Containment> _annotationAnnotation_ContainmentOptionalMultipleAnnotationNested;
	public Containment AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested => _annotationAnnotation_ContainmentOptionalMultipleAnnotationNested.Value;

	private readonly Lazy<Concept> _conceptConcept;
	public Concept ConceptConcept => _conceptConcept.Value;

	private readonly Lazy<Containment> _conceptConcept_ContainmentOptionalMultipleConceptNested;
	public Containment ConceptConcept_ContainmentOptionalMultipleConceptNested => _conceptConcept_ContainmentOptionalMultipleConceptNested.Value;

	private readonly Lazy<Concept> _conceptPartition;
	public Concept ConceptPartition => _conceptPartition.Value;

	private readonly Lazy<Containment> _conceptPartition_ContainmentOptionalMultiple;
	public Containment ConceptPartition_ContainmentOptionalMultiple => _conceptPartition_ContainmentOptionalMultiple.Value;

	private readonly Lazy<Containment> _conceptPartition_ContainmentOptionalSingle;
	public Containment ConceptPartition_ContainmentOptionalSingle => _conceptPartition_ContainmentOptionalSingle.Value;

	private readonly Lazy<Containment> _conceptPartition_ContainmentRequiredMultiple;
	public Containment ConceptPartition_ContainmentRequiredMultiple => _conceptPartition_ContainmentRequiredMultiple.Value;

	private readonly Lazy<Containment> _conceptPartition_ContainmentRequiredSingle;
	public Containment ConceptPartition_ContainmentRequiredSingle => _conceptPartition_ContainmentRequiredSingle.Value;

	private readonly Lazy<Property> _conceptPartition_propertyBooleanOptional;
	public Property ConceptPartition_propertyBooleanOptional => _conceptPartition_propertyBooleanOptional.Value;

	private readonly Lazy<Property> _conceptPartition_propertyBooleanRequired;
	public Property ConceptPartition_propertyBooleanRequired => _conceptPartition_propertyBooleanRequired.Value;

	private readonly Lazy<Property> _conceptPartition_propertyIntegerOptional;
	public Property ConceptPartition_propertyIntegerOptional => _conceptPartition_propertyIntegerOptional.Value;

	private readonly Lazy<Property> _conceptPartition_propertyIntegerRequired;
	public Property ConceptPartition_propertyIntegerRequired => _conceptPartition_propertyIntegerRequired.Value;

	private readonly Lazy<Property> _conceptPartition_propertySdtOptional;
	public Property ConceptPartition_propertySdtOptional => _conceptPartition_propertySdtOptional.Value;

	private readonly Lazy<Property> _conceptPartition_propertySdtRequired;
	public Property ConceptPartition_propertySdtRequired => _conceptPartition_propertySdtRequired.Value;

	private readonly Lazy<Property> _conceptPartition_propertyStringOptional;
	public Property ConceptPartition_propertyStringOptional => _conceptPartition_propertyStringOptional.Value;

	private readonly Lazy<Property> _conceptPartition_propertyStringRequired;
	public Property ConceptPartition_propertyStringRequired => _conceptPartition_propertyStringRequired.Value;

	private readonly Lazy<Reference> _conceptPartition_ReferenceOptionalMultiple;
	public Reference ConceptPartition_ReferenceOptionalMultiple => _conceptPartition_ReferenceOptionalMultiple.Value;

	private readonly Lazy<Reference> _conceptPartition_ReferenceOptionalSingle;
	public Reference ConceptPartition_ReferenceOptionalSingle => _conceptPartition_ReferenceOptionalSingle.Value;

	private readonly Lazy<Reference> _conceptPartition_ReferenceRequiredMultiple;
	public Reference ConceptPartition_ReferenceRequiredMultiple => _conceptPartition_ReferenceRequiredMultiple.Value;

	private readonly Lazy<Reference> _conceptPartition_ReferenceRequiredSingle;
	public Reference ConceptPartition_ReferenceRequiredSingle => _conceptPartition_ReferenceRequiredSingle.Value;

	private readonly Lazy<Interface> _interfaceIface;
	public Interface InterfaceIface => _interfaceIface.Value;

	private readonly Lazy<StructuredDataType> _sdtDecimal;
	public StructuredDataType SdtDecimal => _sdtDecimal.Value;

	private readonly Lazy<Field> _sdtDecimal_fieldFraction;
	public Field SdtDecimal_fieldFraction => _sdtDecimal_fieldFraction.Value;

	private readonly Lazy<Field> _sdtDecimal_fieldWhole;
	public Field SdtDecimal_fieldWhole => _sdtDecimal_fieldWhole.Value;

	private readonly Lazy<StructuredDataType> _sdtNested;
	public StructuredDataType SdtNested => _sdtNested.Value;

	private readonly Lazy<Field> _sdtNested_fieldBoolean;
	public Field SdtNested_fieldBoolean => _sdtNested_fieldBoolean.Value;

	private readonly Lazy<Field> _sdtNested_fieldDecimal;
	public Field SdtNested_fieldDecimal => _sdtNested_fieldDecimal.Value;

	private readonly Lazy<Field> _sdtNested_fieldString;
	public Field SdtNested_fieldString => _sdtNested_fieldString.Value;
}

public partial interface IStructureNameFactory : INodeFactory
{
	public AnnotationAnnotation NewAnnotationAnnotation(string id);
	public AnnotationAnnotation CreateAnnotationAnnotation();
	public ConceptConcept NewConceptConcept(string id);
	public ConceptConcept CreateConceptConcept();
	public ConceptPartition NewConceptPartition(string id);
	public ConceptPartition CreateConceptPartition();
}

public class StructureNameFactory : AbstractBaseNodeFactory, IStructureNameFactory
{
	private readonly StructureNameLanguage _language;
	public StructureNameFactory(StructureNameLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.AnnotationAnnotation.EqualsIdentity(classifier))
			return NewAnnotationAnnotation(id);
		if (_language.ConceptConcept.EqualsIdentity(classifier))
			return NewConceptConcept(id);
		if (_language.ConceptPartition.EqualsIdentity(classifier))
			return NewConceptPartition(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		if (_language.SdtDecimal.EqualsIdentity(structuredDataType))
			return new SdtDecimal((int?)fieldValues.Get(_language.SdtDecimal_fieldFraction), (int?)fieldValues.Get(_language.SdtDecimal_fieldWhole));
		if (_language.SdtNested.EqualsIdentity(structuredDataType))
			return new SdtNested((bool?)fieldValues.Get(_language.SdtNested_fieldBoolean), (SdtDecimal?)fieldValues.Get(_language.SdtNested_fieldDecimal), (string?)fieldValues.Get(_language.SdtNested_fieldString));
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual AnnotationAnnotation NewAnnotationAnnotation(string id) => new(id);
	public virtual AnnotationAnnotation CreateAnnotationAnnotation() => NewAnnotationAnnotation(GetNewId());
	public virtual ConceptConcept NewConceptConcept(string id) => new(id);
	public virtual ConceptConcept CreateConceptConcept() => NewConceptConcept(GetNewId());
	public virtual ConceptPartition NewConceptPartition(string id) => new(id);
	public virtual ConceptPartition CreateConceptPartition() => NewConceptPartition(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-annotation")]
public partial class AnnotationAnnotation : AnnotationInstanceBase, InterfaceIface, INamedWritable
{
	private string? _name = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Name has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(LionWeb.Core.VersionSpecific.V2024_1.BuiltInsLanguage_2024_1), Key = "LionCore-builtins-INamed-name")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string Name { get => _name ?? throw new UnsetFeatureException(_builtIns.INamed_name); set => SetName(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetName([NotNullWhenAttribute(true)] out string? name)
	{
		name = _name;
		return _name != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 INamedWritable INamedWritable.SetName(string value) => SetName(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public AnnotationAnnotation SetName(string value)
	{
		AssureNotNull(value, _builtIns.INamed_name);
		PropertyEventEmitter evt = new(_builtIns.INamed_name, this, value, _name);
		evt.CollectOldData();
		_name = value;
		evt.RaiseEvent();
		return this;
	}

	private readonly List<InterfaceIface> _containmentOptionalMultipleAnnotationNested = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-containment-optional-multiple-annotationNested")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<InterfaceIface> ContainmentOptionalMultipleAnnotationNested { get => _containmentOptionalMultipleAnnotationNested.AsReadOnly(); init => AddContainmentOptionalMultipleAnnotationNested(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetContainmentOptionalMultipleAnnotationNested([NotNullWhenAttribute(true)] out IReadOnlyList<InterfaceIface> containmentOptionalMultipleAnnotationNested)
	{
		containmentOptionalMultipleAnnotationNested = _containmentOptionalMultipleAnnotationNested;
		return _containmentOptionalMultipleAnnotationNested.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public AnnotationAnnotation AddContainmentOptionalMultipleAnnotationNested(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested, this, safeNodes, _containmentOptionalMultipleAnnotationNested, null);
		evt.CollectOldData();
		_containmentOptionalMultipleAnnotationNested.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public AnnotationAnnotation InsertContainmentOptionalMultipleAnnotationNested(int index, IEnumerable<InterfaceIface> nodes)
	{
		AssureInRange(index, _containmentOptionalMultipleAnnotationNested);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
		AssureNoSelfMove(index, safeNodes, _containmentOptionalMultipleAnnotationNested);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested, this, safeNodes, _containmentOptionalMultipleAnnotationNested, index);
		evt.CollectOldData();
		_containmentOptionalMultipleAnnotationNested.InsertRange(index, SetSelfParent(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public AnnotationAnnotation RemoveContainmentOptionalMultipleAnnotationNested(IEnumerable<InterfaceIface> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _containmentOptionalMultipleAnnotationNested, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested, ContainmentRemover<InterfaceIface>(StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested));
		return this;
	}

	public AnnotationAnnotation(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => StructureNameLanguage.Instance.AnnotationAnnotation;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out Object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			result = Name;
			return true;
		}

		if (StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested.EqualsIdentity(feature))
		{
			result = ContainmentOptionalMultipleAnnotationNested;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, Object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				Name = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested.EqualsIdentity(feature))
		{
			var safeNodes = StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested.AsNodes<LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface>(value).ToList();
			ContainmentSetEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested, this, safeNodes, _containmentOptionalMultipleAnnotationNested);
			evt.CollectOldData();
			RemoveSelfParent(_containmentOptionalMultipleAnnotationNested.ToList(), _containmentOptionalMultipleAnnotationNested, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
			_containmentOptionalMultipleAnnotationNested.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested));
			evt.RaiseEvent();
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (_name != default)
			result.Add(_builtIns.INamed_name);
		if (_containmentOptionalMultipleAnnotationNested.Count != 0)
			result.Add(StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _containmentOptionalMultipleAnnotationNested, StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested);
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is InterfaceIface child0 && _containmentOptionalMultipleAnnotationNested.Contains(child0))
			return StructureNameLanguage.Instance.AnnotationAnnotation_ContainmentOptionalMultipleAnnotationNested;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-concept")]
public partial class ConceptConcept : ConceptInstanceBase, InterfaceIface, INamedWritable
{
	private string? _name = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Name has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(LionWeb.Core.VersionSpecific.V2024_1.BuiltInsLanguage_2024_1), Key = "LionCore-builtins-INamed-name")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string Name { get => _name ?? throw new UnsetFeatureException(_builtIns.INamed_name); set => SetName(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetName([NotNullWhenAttribute(true)] out string? name)
	{
		name = _name;
		return _name != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 INamedWritable INamedWritable.SetName(string value) => SetName(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public ConceptConcept SetName(string value)
	{
		AssureNotNull(value, _builtIns.INamed_name);
		PropertyEventEmitter evt = new(_builtIns.INamed_name, this, value, _name);
		evt.CollectOldData();
		_name = value;
		evt.RaiseEvent();
		return this;
	}

	private readonly List<InterfaceIface> _containmentOptionalMultipleConceptNested = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-containment-optional-multiple-conceptNested")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<InterfaceIface> ContainmentOptionalMultipleConceptNested { get => _containmentOptionalMultipleConceptNested.AsReadOnly(); init => AddContainmentOptionalMultipleConceptNested(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetContainmentOptionalMultipleConceptNested([NotNullWhenAttribute(true)] out IReadOnlyList<InterfaceIface> containmentOptionalMultipleConceptNested)
	{
		containmentOptionalMultipleConceptNested = _containmentOptionalMultipleConceptNested;
		return _containmentOptionalMultipleConceptNested.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public ConceptConcept AddContainmentOptionalMultipleConceptNested(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested, this, safeNodes, _containmentOptionalMultipleConceptNested, null);
		evt.CollectOldData();
		_containmentOptionalMultipleConceptNested.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public ConceptConcept InsertContainmentOptionalMultipleConceptNested(int index, IEnumerable<InterfaceIface> nodes)
	{
		AssureInRange(index, _containmentOptionalMultipleConceptNested);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
		AssureNoSelfMove(index, safeNodes, _containmentOptionalMultipleConceptNested);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested, this, safeNodes, _containmentOptionalMultipleConceptNested, index);
		evt.CollectOldData();
		_containmentOptionalMultipleConceptNested.InsertRange(index, SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public ConceptConcept RemoveContainmentOptionalMultipleConceptNested(IEnumerable<InterfaceIface> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _containmentOptionalMultipleConceptNested, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested, ContainmentRemover<InterfaceIface>(StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested));
		return this;
	}

	public ConceptConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => StructureNameLanguage.Instance.ConceptConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out Object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			result = Name;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested.EqualsIdentity(feature))
		{
			result = ContainmentOptionalMultipleConceptNested;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, Object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				Name = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested.EqualsIdentity(feature))
		{
			var safeNodes = StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested.AsNodes<LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface>(value).ToList();
			ContainmentSetEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested, this, safeNodes, _containmentOptionalMultipleConceptNested);
			evt.CollectOldData();
			RemoveSelfParent(_containmentOptionalMultipleConceptNested.ToList(), _containmentOptionalMultipleConceptNested, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
			_containmentOptionalMultipleConceptNested.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested));
			evt.RaiseEvent();
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (_name != default)
			result.Add(_builtIns.INamed_name);
		if (_containmentOptionalMultipleConceptNested.Count != 0)
			result.Add(StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _containmentOptionalMultipleConceptNested, StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested);
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is InterfaceIface child0 && _containmentOptionalMultipleConceptNested.Contains(child0))
			return StructureNameLanguage.Instance.ConceptConcept_ContainmentOptionalMultipleConceptNested;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-partition")]
public partial class ConceptPartition : ConceptInstanceBase, IPartitionInstance<INode>
{
	private readonly List<InterfaceIface> _containmentOptionalMultiple = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-containment-optional-multiple")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<InterfaceIface> ContainmentOptionalMultiple { get => _containmentOptionalMultiple.AsReadOnly(); init => AddContainmentOptionalMultiple(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetContainmentOptionalMultiple([NotNullWhenAttribute(true)] out IReadOnlyList<InterfaceIface> containmentOptionalMultiple)
	{
		containmentOptionalMultiple = _containmentOptionalMultiple;
		return _containmentOptionalMultiple.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public ConceptPartition AddContainmentOptionalMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple, this, safeNodes, _containmentOptionalMultiple, null);
		evt.CollectOldData();
		_containmentOptionalMultiple.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public ConceptPartition InsertContainmentOptionalMultiple(int index, IEnumerable<InterfaceIface> nodes)
	{
		AssureInRange(index, _containmentOptionalMultiple);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
		AssureNoSelfMove(index, safeNodes, _containmentOptionalMultiple);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple, this, safeNodes, _containmentOptionalMultiple, index);
		evt.CollectOldData();
		_containmentOptionalMultiple.InsertRange(index, SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public ConceptPartition RemoveContainmentOptionalMultiple(IEnumerable<InterfaceIface> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _containmentOptionalMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple, ContainmentRemover<InterfaceIface>(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple));
		return this;
	}

	private InterfaceIface? _containmentOptionalSingle = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-containment-optional-single")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public InterfaceIface? ContainmentOptionalSingle { get => _containmentOptionalSingle; set => SetContainmentOptionalSingle(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetContainmentOptionalSingle([NotNullWhenAttribute(true)] out InterfaceIface? containmentOptionalSingle)
	{
		containmentOptionalSingle = _containmentOptionalSingle;
		return _containmentOptionalSingle != null;
	}

	/// <remarks>Optional Single Containment</remarks>
        public ConceptPartition SetContainmentOptionalSingle(InterfaceIface? value)
	{
		ContainmentSingleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalSingle, this, value, _containmentOptionalSingle);
		evt.CollectOldData();
		SetParentNull(_containmentOptionalSingle);
		AttachChild(value);
		_containmentOptionalSingle = value;
		evt.RaiseEvent();
		return this;
	}

	private readonly List<InterfaceIface> _containmentRequiredMultiple = [];
	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If ContainmentRequiredMultiple is empty</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-containment-required-multiple")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public IReadOnlyList<InterfaceIface> ContainmentRequiredMultiple { get => AsNonEmptyReadOnly(_containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple); init => AddContainmentRequiredMultiple(value); }

	/// <remarks>Required Multiple Containment</remarks>
        public bool TryGetContainmentRequiredMultiple([NotNullWhenAttribute(true)] out IReadOnlyList<InterfaceIface> containmentRequiredMultiple)
	{
		containmentRequiredMultiple = _containmentRequiredMultiple;
		return _containmentRequiredMultiple.Count != 0;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both ContainmentRequiredMultiple and nodes are empty</exception>
        public ConceptPartition AddContainmentRequiredMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple, this, safeNodes, _containmentRequiredMultiple, null);
		evt.CollectOldData();
		_containmentRequiredMultiple.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both ContainmentRequiredMultiple and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than ContainmentRequiredMultiple.Count</exception>
        public ConceptPartition InsertContainmentRequiredMultiple(int index, IEnumerable<InterfaceIface> nodes)
	{
		AssureInRange(index, _containmentRequiredMultiple);
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
		AssureNoSelfMove(index, safeNodes, _containmentRequiredMultiple);
		ContainmentAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple, this, safeNodes, _containmentRequiredMultiple, index);
		evt.CollectOldData();
		_containmentRequiredMultiple.InsertRange(index, SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple));
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If ContainmentRequiredMultiple would be empty</exception>
        public ConceptPartition RemoveContainmentRequiredMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
		AssureNotClearing(safeNodes, _containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
		RemoveSelfParent(safeNodes, _containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple, ContainmentRemover<InterfaceIface>(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple));
		return this;
	}

	private InterfaceIface? _containmentRequiredSingle = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If ContainmentRequiredSingle has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-containment-required-single")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public InterfaceIface ContainmentRequiredSingle { get => _containmentRequiredSingle ?? throw new UnsetFeatureException(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle); set => SetContainmentRequiredSingle(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetContainmentRequiredSingle([NotNullWhenAttribute(true)] out InterfaceIface? containmentRequiredSingle)
	{
		containmentRequiredSingle = _containmentRequiredSingle;
		return _containmentRequiredSingle != null;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public ConceptPartition SetContainmentRequiredSingle(InterfaceIface value)
	{
		AssureNotNull(value, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle);
		ContainmentSingleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle, this, value, _containmentRequiredSingle);
		evt.CollectOldData();
		SetParentNull(_containmentRequiredSingle);
		AttachChild(value);
		_containmentRequiredSingle = value;
		evt.RaiseEvent();
		return this;
	}

	private bool? _propertyBooleanOptional = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-boolean-optional")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public bool? PropertyBooleanOptional { get => _propertyBooleanOptional; set => SetPropertyBooleanOptional(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetPropertyBooleanOptional([NotNullWhenAttribute(true)] out bool? propertyBooleanOptional)
	{
		propertyBooleanOptional = _propertyBooleanOptional;
		return _propertyBooleanOptional != null;
	}

	/// <remarks>Optional Property</remarks>
        public ConceptPartition SetPropertyBooleanOptional(bool? value)
	{
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertyBooleanOptional, this, value, _propertyBooleanOptional);
		evt.CollectOldData();
		_propertyBooleanOptional = value;
		evt.RaiseEvent();
		return this;
	}

	private bool? _propertyBooleanRequired = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If PropertyBooleanRequired has not been set</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-boolean-required")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public bool PropertyBooleanRequired { get => _propertyBooleanRequired ?? throw new UnsetFeatureException(StructureNameLanguage.Instance.ConceptPartition_propertyBooleanRequired); set => SetPropertyBooleanRequired(value); }

	/// <remarks>Required Property</remarks>
        public bool TryGetPropertyBooleanRequired([NotNullWhenAttribute(true)] out bool? propertyBooleanRequired)
	{
		propertyBooleanRequired = _propertyBooleanRequired;
		return _propertyBooleanRequired != null;
	}

	/// <remarks>Required Property</remarks>
        public ConceptPartition SetPropertyBooleanRequired(bool value)
	{
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertyBooleanRequired, this, value, _propertyBooleanRequired);
		evt.CollectOldData();
		_propertyBooleanRequired = value;
		evt.RaiseEvent();
		return this;
	}

	private int? _propertyIntegerOptional = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-integer-optional")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public int? PropertyIntegerOptional { get => _propertyIntegerOptional; set => SetPropertyIntegerOptional(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetPropertyIntegerOptional([NotNullWhenAttribute(true)] out int? propertyIntegerOptional)
	{
		propertyIntegerOptional = _propertyIntegerOptional;
		return _propertyIntegerOptional != null;
	}

	/// <remarks>Optional Property</remarks>
        public ConceptPartition SetPropertyIntegerOptional(int? value)
	{
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertyIntegerOptional, this, value, _propertyIntegerOptional);
		evt.CollectOldData();
		_propertyIntegerOptional = value;
		evt.RaiseEvent();
		return this;
	}

	private int? _propertyIntegerRequired = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If PropertyIntegerRequired has not been set</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-integer-required")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public int PropertyIntegerRequired { get => _propertyIntegerRequired ?? throw new UnsetFeatureException(StructureNameLanguage.Instance.ConceptPartition_propertyIntegerRequired); set => SetPropertyIntegerRequired(value); }

	/// <remarks>Required Property</remarks>
        public bool TryGetPropertyIntegerRequired([NotNullWhenAttribute(true)] out int? propertyIntegerRequired)
	{
		propertyIntegerRequired = _propertyIntegerRequired;
		return _propertyIntegerRequired != null;
	}

	/// <remarks>Required Property</remarks>
        public ConceptPartition SetPropertyIntegerRequired(int value)
	{
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertyIntegerRequired, this, value, _propertyIntegerRequired);
		evt.CollectOldData();
		_propertyIntegerRequired = value;
		evt.RaiseEvent();
		return this;
	}

	private SdtNested? _propertySdtOptional = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-sdt-optional")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public SdtNested? PropertySdtOptional { get => _propertySdtOptional; set => SetPropertySdtOptional(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetPropertySdtOptional([NotNullWhenAttribute(true)] out SdtNested? propertySdtOptional)
	{
		propertySdtOptional = _propertySdtOptional;
		return _propertySdtOptional != null;
	}

	/// <remarks>Optional Property</remarks>
        public ConceptPartition SetPropertySdtOptional(SdtNested? value)
	{
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertySdtOptional, this, value, _propertySdtOptional);
		evt.CollectOldData();
		_propertySdtOptional = value;
		evt.RaiseEvent();
		return this;
	}

	private SdtNested? _propertySdtRequired = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If PropertySdtRequired has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-sdt-required")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public SdtNested PropertySdtRequired { get => _propertySdtRequired ?? throw new UnsetFeatureException(StructureNameLanguage.Instance.ConceptPartition_propertySdtRequired); set => SetPropertySdtRequired(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetPropertySdtRequired([NotNullWhenAttribute(true)] out SdtNested? propertySdtRequired)
	{
		propertySdtRequired = _propertySdtRequired;
		return _propertySdtRequired != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public ConceptPartition SetPropertySdtRequired(SdtNested value)
	{
		AssureNotNull(value, StructureNameLanguage.Instance.ConceptPartition_propertySdtRequired);
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertySdtRequired, this, value, _propertySdtRequired);
		evt.CollectOldData();
		_propertySdtRequired = value;
		evt.RaiseEvent();
		return this;
	}

	private string? _propertyStringOptional = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-string-optional")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public string? PropertyStringOptional { get => _propertyStringOptional; set => SetPropertyStringOptional(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetPropertyStringOptional([NotNullWhenAttribute(true)] out string? propertyStringOptional)
	{
		propertyStringOptional = _propertyStringOptional;
		return _propertyStringOptional != null;
	}

	/// <remarks>Optional Property</remarks>
        public ConceptPartition SetPropertyStringOptional(string? value)
	{
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertyStringOptional, this, value, _propertyStringOptional);
		evt.CollectOldData();
		_propertyStringOptional = value;
		evt.RaiseEvent();
		return this;
	}

	private string? _propertyStringRequired = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If PropertyStringRequired has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-property-string-required")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string PropertyStringRequired { get => _propertyStringRequired ?? throw new UnsetFeatureException(StructureNameLanguage.Instance.ConceptPartition_propertyStringRequired); set => SetPropertyStringRequired(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetPropertyStringRequired([NotNullWhenAttribute(true)] out string? propertyStringRequired)
	{
		propertyStringRequired = _propertyStringRequired;
		return _propertyStringRequired != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public ConceptPartition SetPropertyStringRequired(string value)
	{
		AssureNotNull(value, StructureNameLanguage.Instance.ConceptPartition_propertyStringRequired);
		PropertyEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_propertyStringRequired, this, value, _propertyStringRequired);
		evt.CollectOldData();
		_propertyStringRequired = value;
		evt.RaiseEvent();
		return this;
	}

	private readonly List<InterfaceIface> _referenceOptionalMultiple = [];
	/// <remarks>Optional Multiple Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-reference-optional-multiple")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = true)]
	public IReadOnlyList<InterfaceIface> ReferenceOptionalMultiple { get => _referenceOptionalMultiple.AsReadOnly(); init => AddReferenceOptionalMultiple(value); }

	/// <remarks>Optional Multiple Reference</remarks>
        public bool TryGetReferenceOptionalMultiple([NotNullWhenAttribute(true)] out IReadOnlyList<InterfaceIface> referenceOptionalMultiple)
	{
		referenceOptionalMultiple = _referenceOptionalMultiple;
		return _referenceOptionalMultiple.Count != 0;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public ConceptPartition AddReferenceOptionalMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		ReferenceAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple, this, safeNodes, _referenceOptionalMultiple.Count);
		evt.CollectOldData();
		_referenceOptionalMultiple.AddRange(safeNodes);
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public ConceptPartition InsertReferenceOptionalMultiple(int index, IEnumerable<InterfaceIface> nodes)
	{
		AssureInRange(index, _referenceOptionalMultiple);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		ReferenceAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple, this, safeNodes, index);
		evt.CollectOldData();
		_referenceOptionalMultiple.InsertRange(index, safeNodes);
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public ConceptPartition RemoveReferenceOptionalMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		RemoveAll(safeNodes, _referenceOptionalMultiple, ReferenceRemover<InterfaceIface>(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple));
		return this;
	}

	private InterfaceIface? _referenceOptionalSingle = null;
	/// <remarks>Optional Single Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-reference-optional-single")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = true)]
	public InterfaceIface? ReferenceOptionalSingle { get => _referenceOptionalSingle; set => SetReferenceOptionalSingle(value); }

	/// <remarks>Optional Single Reference</remarks>
        public bool TryGetReferenceOptionalSingle([NotNullWhenAttribute(true)] out InterfaceIface? referenceOptionalSingle)
	{
		referenceOptionalSingle = _referenceOptionalSingle;
		return _referenceOptionalSingle != null;
	}

	/// <remarks>Optional Single Reference</remarks>
        public ConceptPartition SetReferenceOptionalSingle(InterfaceIface? value)
	{
		ReferenceSingleEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalSingle, this, value, _referenceOptionalSingle);
		evt.CollectOldData();
		_referenceOptionalSingle = value;
		evt.RaiseEvent();
		return this;
	}

	private readonly List<InterfaceIface> _referenceRequiredMultiple = [];
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If ReferenceRequiredMultiple is empty</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-reference-required-multiple")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public IReadOnlyList<InterfaceIface> ReferenceRequiredMultiple { get => AsNonEmptyReadOnly(_referenceRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple); init => AddReferenceRequiredMultiple(value); }

	/// <remarks>Required Multiple Reference</remarks>
        public bool TryGetReferenceRequiredMultiple([NotNullWhenAttribute(true)] out IReadOnlyList<InterfaceIface> referenceRequiredMultiple)
	{
		referenceRequiredMultiple = _referenceRequiredMultiple;
		return _referenceRequiredMultiple.Count != 0;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both ReferenceRequiredMultiple and nodes are empty</exception>
        public ConceptPartition AddReferenceRequiredMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		AssureNonEmpty(safeNodes, _referenceRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		ReferenceAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple, this, safeNodes, _referenceRequiredMultiple.Count);
		evt.CollectOldData();
		_referenceRequiredMultiple.AddRange(safeNodes);
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both ReferenceRequiredMultiple and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than ReferenceRequiredMultiple.Count</exception>
        public ConceptPartition InsertReferenceRequiredMultiple(int index, IEnumerable<InterfaceIface> nodes)
	{
		AssureInRange(index, _referenceRequiredMultiple);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		AssureNonEmpty(safeNodes, _referenceRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		ReferenceAddMultipleEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple, this, safeNodes, index);
		evt.CollectOldData();
		_referenceRequiredMultiple.InsertRange(index, safeNodes);
		evt.RaiseEvent();
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If ReferenceRequiredMultiple would be empty</exception>
        public ConceptPartition RemoveReferenceRequiredMultiple(IEnumerable<InterfaceIface> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		AssureNonEmpty(safeNodes, _referenceRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		AssureNotClearing(safeNodes, _referenceRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		RemoveAll(safeNodes, _referenceRequiredMultiple, ReferenceRemover<InterfaceIface>(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple));
		return this;
	}

	private InterfaceIface? _referenceRequiredSingle = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If ReferenceRequiredSingle has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-reference-required-single")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public InterfaceIface ReferenceRequiredSingle { get => _referenceRequiredSingle ?? throw new UnsetFeatureException(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredSingle); set => SetReferenceRequiredSingle(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetReferenceRequiredSingle([NotNullWhenAttribute(true)] out InterfaceIface? referenceRequiredSingle)
	{
		referenceRequiredSingle = _referenceRequiredSingle;
		return _referenceRequiredSingle != null;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public ConceptPartition SetReferenceRequiredSingle(InterfaceIface value)
	{
		AssureNotNull(value, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredSingle);
		ReferenceSingleEventEmitter evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredSingle, this, value, _referenceRequiredSingle);
		evt.CollectOldData();
		_referenceRequiredSingle = value;
		evt.RaiseEvent();
		return this;
	}

	public ConceptPartition(string id) : base(id)
	{
		_eventHandler = new(this);
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => StructureNameLanguage.Instance.ConceptPartition;
	private readonly PartitionEventHandler _eventHandler;
	public IPartitionPublisher? GetPublisher() => _eventHandler;
	public IPartitionCommander? GetCommander() => _eventHandler;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out Object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple.EqualsIdentity(feature))
		{
			result = ContainmentOptionalMultiple;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalSingle.EqualsIdentity(feature))
		{
			result = ContainmentOptionalSingle;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple.EqualsIdentity(feature))
		{
			result = ContainmentRequiredMultiple;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle.EqualsIdentity(feature))
		{
			result = ContainmentRequiredSingle;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyBooleanOptional.EqualsIdentity(feature))
		{
			result = PropertyBooleanOptional;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyBooleanRequired.EqualsIdentity(feature))
		{
			result = PropertyBooleanRequired;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyIntegerOptional.EqualsIdentity(feature))
		{
			result = PropertyIntegerOptional;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyIntegerRequired.EqualsIdentity(feature))
		{
			result = PropertyIntegerRequired;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertySdtOptional.EqualsIdentity(feature))
		{
			result = PropertySdtOptional;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertySdtRequired.EqualsIdentity(feature))
		{
			result = PropertySdtRequired;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyStringOptional.EqualsIdentity(feature))
		{
			result = PropertyStringOptional;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyStringRequired.EqualsIdentity(feature))
		{
			result = PropertyStringRequired;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple.EqualsIdentity(feature))
		{
			result = ReferenceOptionalMultiple;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalSingle.EqualsIdentity(feature))
		{
			result = ReferenceOptionalSingle;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple.EqualsIdentity(feature))
		{
			result = ReferenceRequiredMultiple;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredSingle.EqualsIdentity(feature))
		{
			result = ReferenceRequiredSingle;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, Object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple.EqualsIdentity(feature))
		{
			var safeNodes = StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple.AsNodes<LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface>(value).ToList();
			ContainmentSetEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple, this, safeNodes, _containmentOptionalMultiple);
			evt.CollectOldData();
			RemoveSelfParent(_containmentOptionalMultiple.ToList(), _containmentOptionalMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
			_containmentOptionalMultiple.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple));
			evt.RaiseEvent();
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalSingle.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface)
			{
				ContainmentOptionalSingle = (LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface?)value;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple.EqualsIdentity(feature))
		{
			var safeNodes = StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple.AsNodes<LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface>(value).ToList();
			AssureNonEmpty(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
			ContainmentSetEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple, this, safeNodes, _containmentRequiredMultiple);
			evt.CollectOldData();
			RemoveSelfParent(_containmentRequiredMultiple.ToList(), _containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
			_containmentRequiredMultiple.AddRange(SetSelfParent(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple));
			evt.RaiseEvent();
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle.EqualsIdentity(feature))
		{
			if (value is LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface v)
			{
				ContainmentRequiredSingle = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyBooleanOptional.EqualsIdentity(feature))
		{
			if (value is null or bool)
			{
				PropertyBooleanOptional = (bool?)value;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyBooleanRequired.EqualsIdentity(feature))
		{
			if (value is bool v)
			{
				PropertyBooleanRequired = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyIntegerOptional.EqualsIdentity(feature))
		{
			if (value is null or int)
			{
				PropertyIntegerOptional = (int?)value;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyIntegerRequired.EqualsIdentity(feature))
		{
			if (value is int v)
			{
				PropertyIntegerRequired = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertySdtOptional.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.SdtNested)
			{
				PropertySdtOptional = (LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.SdtNested?)value;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertySdtRequired.EqualsIdentity(feature))
		{
			if (value is LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.SdtNested v)
			{
				PropertySdtRequired = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyStringOptional.EqualsIdentity(feature))
		{
			if (value is null or string)
			{
				PropertyStringOptional = (string?)value;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_propertyStringRequired.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				PropertyStringRequired = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple.EqualsIdentity(feature))
		{
			var safeNodes = StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple.AsNodes<LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface>(value).ToList();
			AssureNotNull(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
			AssureNotNullMembers(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
			ReferenceSetEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple, this, safeNodes, _referenceOptionalMultiple);
			evt.CollectOldData();
			_referenceOptionalMultiple.Clear();
			_referenceOptionalMultiple.AddRange(safeNodes);
			evt.RaiseEvent();
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalSingle.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface)
			{
				ReferenceOptionalSingle = (LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface?)value;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple.EqualsIdentity(feature))
		{
			var safeNodes = StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple.AsNodes<LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface>(value).ToList();
			AssureNonEmpty(safeNodes, StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
			ReferenceSetEventEmitter<InterfaceIface> evt = new(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple, this, safeNodes, _referenceRequiredMultiple);
			evt.CollectOldData();
			_referenceRequiredMultiple.Clear();
			_referenceRequiredMultiple.AddRange(safeNodes);
			evt.RaiseEvent();
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredSingle.EqualsIdentity(feature))
		{
			if (value is LionWeb.Integration.Languages.Generated.V2024_1.StructureName.M2.InterfaceIface v)
			{
				ReferenceRequiredSingle = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (_containmentOptionalMultiple.Count != 0)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
		if (_containmentOptionalSingle != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalSingle);
		if (_containmentRequiredMultiple.Count != 0)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
		if (_containmentRequiredSingle != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle);
		if (_propertyBooleanOptional != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertyBooleanOptional);
		if (_propertyBooleanRequired != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertyBooleanRequired);
		if (_propertyIntegerOptional != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertyIntegerOptional);
		if (_propertyIntegerRequired != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertyIntegerRequired);
		if (_propertySdtOptional != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertySdtOptional);
		if (_propertySdtRequired != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertySdtRequired);
		if (_propertyStringOptional != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertyStringOptional);
		if (_propertyStringRequired != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_propertyStringRequired);
		if (_referenceOptionalMultiple.Count != 0)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalMultiple);
		if (_referenceOptionalSingle != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ReferenceOptionalSingle);
		if (_referenceRequiredMultiple.Count != 0)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredMultiple);
		if (_referenceRequiredSingle != default)
			result.Add(StructureNameLanguage.Instance.ConceptPartition_ReferenceRequiredSingle);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _containmentOptionalMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple);
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalSingle.EqualsIdentity(c))
		{
			_containmentOptionalSingle = null;
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _containmentRequiredMultiple, StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple);
			return true;
		}

		if (StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle.EqualsIdentity(c))
		{
			_containmentRequiredSingle = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is InterfaceIface child0 && _containmentOptionalMultiple.Contains(child0))
			return StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalMultiple;
		if (ReferenceEquals(_containmentOptionalSingle, child))
			return StructureNameLanguage.Instance.ConceptPartition_ContainmentOptionalSingle;
		if (child is InterfaceIface child2 && _containmentRequiredMultiple.Contains(child2))
			return StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredMultiple;
		if (ReferenceEquals(_containmentRequiredSingle, child))
			return StructureNameLanguage.Instance.ConceptPartition_ContainmentRequiredSingle;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-interface")]
public partial interface InterfaceIface : INamedWritable, INode
{
}

[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-sdt-decimal")]
public readonly record struct SdtDecimal : IStructuredDataTypeInstance
{
	private readonly int? _fieldFraction;
	[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-field-decimal-fraction")]
	public int FieldFraction { get => _fieldFraction ?? throw new UnsetFieldException(StructureNameLanguage.Instance.SdtDecimal_fieldFraction); init => _fieldFraction = value; }

	private readonly int? _fieldWhole;
	[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-field-decimal-whole")]
	public int FieldWhole { get => _fieldWhole ?? throw new UnsetFieldException(StructureNameLanguage.Instance.SdtDecimal_fieldWhole); init => _fieldWhole = value; }

	public SdtDecimal()
	{
		_fieldFraction = null;
		_fieldWhole = null;
	}

	internal SdtDecimal(int? fieldFraction, int? fieldWhole)
	{
		_fieldFraction = fieldFraction;
		_fieldWhole = fieldWhole;
	}

	/// <inheritdoc/>
        public StructuredDataType GetStructuredDataType() => StructureNameLanguage.Instance.SdtDecimal;
	/// <inheritdoc/>
        public IEnumerable<Field> CollectAllSetFields()
	{
		List<Field> result = [];
		if (_fieldFraction != null)
			result.Add(StructureNameLanguage.Instance.SdtDecimal_fieldFraction);
		if (_fieldWhole != null)
			result.Add(StructureNameLanguage.Instance.SdtDecimal_fieldWhole);
		return result;
	}

	/// <inheritdoc/>
        public Object? Get(Field field)
	{
		if (StructureNameLanguage.Instance.SdtDecimal_fieldFraction.EqualsIdentity(field))
			return FieldFraction;
		if (StructureNameLanguage.Instance.SdtDecimal_fieldWhole.EqualsIdentity(field))
			return FieldWhole;
		throw new UnsetFieldException(field);
	}

	public override string ToString() => $"SdtDecimal {{ FieldFraction = {_fieldFraction}, FieldWhole = {_fieldWhole} }}";
}

[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-sdt-neested")]
public readonly record struct SdtNested : IStructuredDataTypeInstance
{
	private readonly bool? _fieldBoolean;
	[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-field-nested-boolean")]
	public bool FieldBoolean { get => _fieldBoolean ?? throw new UnsetFieldException(StructureNameLanguage.Instance.SdtNested_fieldBoolean); init => _fieldBoolean = value; }

	private readonly SdtDecimal? _fieldDecimal;
	[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-field-nested-decimal")]
	public SdtDecimal FieldDecimal { get => _fieldDecimal ?? throw new UnsetFieldException(StructureNameLanguage.Instance.SdtNested_fieldDecimal); init => _fieldDecimal = value; }

	private readonly string? _fieldString;
	[LionCoreMetaPointer(Language = typeof(StructureNameLanguage), Key = "key-field-nested-string")]
	public string FieldString { get => _fieldString ?? throw new UnsetFieldException(StructureNameLanguage.Instance.SdtNested_fieldString); init => _fieldString = value; }

	public SdtNested()
	{
		_fieldBoolean = null;
		_fieldDecimal = null;
		_fieldString = null;
	}

	internal SdtNested(bool? fieldBoolean, SdtDecimal? fieldDecimal, string? fieldString)
	{
		_fieldBoolean = fieldBoolean;
		_fieldDecimal = fieldDecimal;
		_fieldString = fieldString;
	}

	/// <inheritdoc/>
        public StructuredDataType GetStructuredDataType() => StructureNameLanguage.Instance.SdtNested;
	/// <inheritdoc/>
        public IEnumerable<Field> CollectAllSetFields()
	{
		List<Field> result = [];
		if (_fieldBoolean != null)
			result.Add(StructureNameLanguage.Instance.SdtNested_fieldBoolean);
		if (_fieldDecimal != null)
			result.Add(StructureNameLanguage.Instance.SdtNested_fieldDecimal);
		if (_fieldString != null)
			result.Add(StructureNameLanguage.Instance.SdtNested_fieldString);
		return result;
	}

	/// <inheritdoc/>
        public Object? Get(Field field)
	{
		if (StructureNameLanguage.Instance.SdtNested_fieldBoolean.EqualsIdentity(field))
			return FieldBoolean;
		if (StructureNameLanguage.Instance.SdtNested_fieldDecimal.EqualsIdentity(field))
			return FieldDecimal;
		if (StructureNameLanguage.Instance.SdtNested_fieldString.EqualsIdentity(field))
			return FieldString;
		throw new UnsetFieldException(field);
	}

	public override string ToString() => $"SdtNested {{ FieldBoolean = {_fieldBoolean}, FieldDecimal = {_fieldDecimal}, FieldString = {_fieldString} }}";
}
# README

This .NET solution holds the prototypal implementation of the WebSocket-driven client and repository implementations of the LionWeb delta protocol.

## Overview

* `LionWeb.Integration.Build`:: Generates C# variants of the test languages in `<gitroot>/src/languages`
* `LionWeb.Integration.Languages`:: Hosts the languages generated by `LionWeb.Integration.Build`.
* `LionWeb.Integration.WebSocket.Client`:: A C# LionWeb delta protocol over WebSocket client.
* `LionWeb.Integration.WebSocket.Server`:: A C# LionWeb delta protocol over WebSocket server.
* `LionWeb.Integration.WebSocket.Tests`:: The actual integration tests as NUnit tests.

## Test structure
The main use case for this C# solution is testing the C# implementations against other implementations.
Thus, in **Client** tests the _system under test_ is the C# client, connecting to different server implementations.
Respectively, in **Server** tests the C# server connects to different client implementations.

In both cases, we configure the different "foreign" implementations by `TestFixture` attributes (curtesy of NUnit).

### How to add a new "foreign" implementation

All Server tests inherit from `WebSocketServerTestBase`, thus they also inherit `TestFixture` attributes.
For each "foreign" client to test against, we have one literal in enum `ClientProcesses`, and a corresponding `TestFixture(ClientProcesses.<foreignClientLiteral>)` attribute on `WebSocketServerTestBase`.
We also need a corresponding entry in `ClientProcessesExtensions.Create()`'s `switch`.
This sets up an os process to start the "foreign" client.

Note: We deliberately use external processes for all clients, including the C# one.
This guarantees no interference between server and client, and enables implementations in different languages.

Client tests work exactly the same -- we put `TestFixture(ServerProcesses.<foreignServerLiteral>)` attributes on `WebSocketClientTestBase` and use `ServerProcessesExtensions.Create()` to set up the "foreign" server process.

### How to distinguish scenarios
When setting up the process of the "foreign" implementation, we need to distinguish which scenario we're running in (see next section for a description of the scenarios).

We use preprocessor directives to distinguish the scenarios:

```csharp
// Accesses `<DefineConstants>USE_LION_WEB_PACKAGES</DefineConstants>` from .csproj 
#if USE_LION_WEB_PACKAGES
    Process result = TsNpxPackageClient(cmdLine);
#else
    Process result = TsRelativeDirectoryClient(cmdLine);
#endif
```

## How to run different Scenarios

### Using "foreign" implementations from packages
In this scenario, we use released versions of "foreign" implementations, retrieved from their respective package infrastructure (e.g. nuget, npm, maven, ...).

We select this scenario by building this C# solution with `Release` Configuration, e.g. 

```shell
dotnet test --configuration Release
```

If needed, we use methods in `SetupTrace` (attributed with `[OneTimeSetUp]`) to download the "foreign" implementation.
Their versions should be configured in `Directory.Packages.props`, and can be overridden with environment variables.

Example:

`Directory.Packages.props` content:

```xml
<Project>
  <PropertyGroup>
    ...
    <!-- Can be overwritten by environment variable TS_DELTA_CLI_VERSION -->
    <TS_DELTA_CLI_VERSION Condition="'$(TS_DELTA_CLI_VERSION)' == ''">0.7.0-beta.13</TS_DELTA_CLI_VERSION>
  </PropertyGroup>
  ...
</Project>
```

We need the following setting in `LionWeb.Integration.WebSocket.Tests.csproj` to smuggle the value into the runtime:

```xml
<Project Sdk="Microsoft.NET.Sdk">
    ...
    <ItemGroup>
      <AssemblyAttribute Include="LionWeb.Integration.WebSocket.Tests.AssemblyConfigurationAttribute">
        <_Parameter1>LionWebTsVersion</_Parameter1>
        <_Parameter2>$(TS_DELTA_CLI_VERSION)</_Parameter2>
      </AssemblyAttribute>
      ...
    </ItemGroup>
    ...
</Project>
```

Then we can access the value at runtime:
```csharp
static string TsDeltaCliVersion => AssemblyConfigurationAttribute.Get("LionWebTsVersion");
```

### Using "foreign" implementations from local directories
In this scenario, we use implementations from locally present directories.
The implementations need to be prepared in their own way (e.g. compiled, bundled, ...) -- out of scope of this document.

We select this scenario by building this C# solution with `Debug` Configuration, e.g.

```shell
dotnet test --configuration Debug
```

We assume the local implementation is present in a directory relative to this git root.
When preparing the process (<a href="#Test structure">as described</a>), assume the current directory is `<gitroot>/src/cs/LionWeb.Integration.WebSocket.Tests/bin/Debug/netX.Y`.

## Currently supported "foreign" implementations

### Servers

* `CSharp`:: Implementation in `LionWeb.Integration.WebSocket.Server` in this git repository.  
  Uses either `LionWeb-CSharp` / `LionWeb-CSharp-Protocol-Delta` nuget packages in version `LionWebCSharpVersion` (_package_ scenario) or directory `<gitroot>/../lionweb-csharp` (_local directories_ scenario).
* `LionWebServer`:: <a href="https://github.com/LionWeb-io/lionweb-server">lionweb-server</a>.  
  Does not support _package_ scenario yet, thus disabled.

### Clients
* `CSharp`:: Implementation in `LionWeb.Integration.WebSocket.Client` in this git repository.  
  Uses either `LionWeb-CSharp` / `LionWeb-CSharp-Protocol-Delta` nuget packages (_package_ scenario) or directory `<gitroot>/../lionweb-csharp` (_local directories_ scenario).
* `Ts`:: <a href="https://github.com/LionWeb-io/lionweb-typescript">lionweb-typescript</a>.  
  Uses either `lionweb/delta-protocol-test-cli` npm package in version `TS_DELTA_CLI_VERSION` (_package_ scenario) or directory `<gitroot>/../lionweb-typescript/packages/delta-protocol-test-cli` (_local directories_ scenario).
